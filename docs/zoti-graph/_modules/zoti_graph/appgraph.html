
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>zoti_graph.appgraph &#8212; zoti-graph 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for zoti_graph.appgraph</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span>

<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

<span class="kn">import</span> <span class="nn">zoti_graph.core</span> <span class="k">as</span> <span class="nn">ty</span>
<span class="kn">import</span> <span class="nn">zoti_graph.tokens</span> <span class="k">as</span> <span class="nn">tok</span>
<span class="kn">import</span> <span class="nn">zoti_graph.util</span> <span class="k">as</span> <span class="nn">util</span>
<span class="kn">from</span> <span class="nn">zoti_graph.core</span> <span class="kn">import</span> <span class="n">Uid</span>


<div class="viewcode-block" id="AppGraph"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph">[docs]</a><span class="k">class</span> <span class="nc">AppGraph</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A ZOTI application graph. Its methods are meant as general purpose</span>
<span class="sd">    utilities, however for more advanced functionality one might apply</span>
<span class="sd">    `NetworkX &lt;https://networkx.org/documentation/stable/index.html&gt;`_</span>
<span class="sd">    algorithms directly on its ``ir`` member.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">root</span><span class="p">:</span> <span class="n">Uid</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The ID of the root node&quot;&quot;&quot;</span>

    <span class="n">ir</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Internal representation of a ZOTI model as simple annotated digraph. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">Uid</span><span class="p">()):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ir</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">Uid</span><span class="p">)</span> <span class="k">else</span> <span class="n">Uid</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

<div class="viewcode-block" id="AppGraph.reset"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resets the current application graph and sets the *root* node ID.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ir</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span></div>

<div class="viewcode-block" id="AppGraph.entry"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.entry">[docs]</a>    <span class="k">def</span> <span class="nf">entry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">Uid</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Uid</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a ZOTI graph entry with a given identifier. If only *u* is</span>
<span class="sd">        provided it searches for a node or a port, if both *u* and *v*</span>
<span class="sd">        are provided it searches for an edge. Returns ``None`` if the</span>
<span class="sd">        identifier does not exist.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">tok</span><span class="o">.</span><span class="n">KEY_ENTRY</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">tok</span><span class="o">.</span><span class="n">KEY_ENTRY</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;node </span><span class="si">{</span><span class="n">u</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;edge (</span><span class="si">{</span><span class="n">u</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>

<div class="viewcode-block" id="AppGraph.get_mark"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.get_mark">[docs]</a>    <span class="k">def</span> <span class="nf">get_mark</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gets the value of a marking named *key* associated with an entry</span>
<span class="sd">        identified with *u* and *v* (see :meth:`entry`).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">entry</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span></div>

<div class="viewcode-block" id="AppGraph.add_mark"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.add_mark">[docs]</a>    <span class="k">def</span> <span class="nf">add_mark</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the value of a marking named *key* associated with an entry</span>
<span class="sd">        identified with *u* and *v* (see :meth:`entry`).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entry</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">mark</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>

<div class="viewcode-block" id="AppGraph.decouple"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.decouple">[docs]</a>    <span class="k">def</span> <span class="nf">decouple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Makes a deepcopy of an entry and replaces the original. Useful</span>
<span class="sd">        after replication-based transformations (e.g. port inference).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">uid</span><span class="p">)</span>
        <span class="n">new_entry</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="n">tok</span><span class="o">.</span><span class="n">KEY_ENTRY</span><span class="p">])</span>
        <span class="n">ret</span><span class="p">[</span><span class="n">tok</span><span class="o">.</span><span class="n">KEY_ENTRY</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_entry</span></div>

<div class="viewcode-block" id="AppGraph.new"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.new">[docs]</a>    <span class="k">def</span> <span class="nf">new</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uid</span><span class="p">:</span> <span class="n">Uid</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Uid</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds a new ZOTI node or port object to the current app</span>
<span class="sd">        graph. Returns *uid* for chaining it with other functions (see</span>
<span class="sd">        :meth:`register_child` or</span>
<span class="sd">        :meth:`register_port`)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="n">tok</span><span class="o">.</span><span class="n">KEY_ENTRY</span><span class="p">:</span> <span class="n">obj</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">uid</span></div>

<div class="viewcode-block" id="AppGraph.register_port"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.register_port">[docs]</a>    <span class="k">def</span> <span class="nf">register_port</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_id</span><span class="p">:</span> <span class="n">Uid</span><span class="p">,</span> <span class="n">port_id</span><span class="p">:</span> <span class="n">Uid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Uid</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Registers a pre-created port to a node (see :meth:`new`). Returns</span>
<span class="sd">        *port_id*.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">parent_id</span><span class="p">,</span> <span class="n">port_id</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">ty</span><span class="o">.</span><span class="n">Relation</span><span class="o">.</span><span class="n">PORT</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">port_id</span></div>

<div class="viewcode-block" id="AppGraph.register_child"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.register_child">[docs]</a>    <span class="k">def</span> <span class="nf">register_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_id</span><span class="p">:</span> <span class="n">Uid</span><span class="p">,</span> <span class="n">child_id</span><span class="p">:</span> <span class="n">Uid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Uid</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Registers a pre-created child node to a parent (see</span>
<span class="sd">        :meth:`new`). Returns *child_id*.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">parent_id</span><span class="p">,</span> <span class="n">child_id</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">ty</span><span class="o">.</span><span class="n">Relation</span><span class="o">.</span><span class="n">CHILD</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">child_id</span></div>

<div class="viewcode-block" id="AppGraph.ports"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.ports">[docs]</a>    <span class="k">def</span> <span class="nf">ports</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_id</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Uid</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a list of IDs for all the ports of this parent. The result</span>
<span class="sd">        can be filtered by passing a *select* function on</span>
<span class="sd">        :class:`zoti_graph.core.Port` entries.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">v</span>
                <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">out_edges</span><span class="p">(</span><span class="n">parent_id</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">tok</span><span class="o">.</span><span class="n">ATTR_EDGE_KIND</span><span class="p">]</span> <span class="o">==</span> <span class="n">ty</span><span class="o">.</span><span class="n">Relation</span><span class="o">.</span><span class="n">PORT</span>
                <span class="k">if</span> <span class="n">select</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">tok</span><span class="o">.</span><span class="n">KEY_ENTRY</span><span class="p">])</span>
            <span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;node </span><span class="si">{</span><span class="n">parent_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="AppGraph.children"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.children">[docs]</a>    <span class="k">def</span> <span class="nf">children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_id</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Uid</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a list of IDs for all the children of this parent. The</span>
<span class="sd">        result can be filtered by passing a *select* function on</span>
<span class="sd">        entries derived from :class:`zoti_graph.core.NodeABC`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">v</span>
                <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">out_edges</span><span class="p">(</span><span class="n">parent_id</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">tok</span><span class="o">.</span><span class="n">ATTR_EDGE_KIND</span><span class="p">]</span> <span class="o">==</span> <span class="n">ty</span><span class="o">.</span><span class="n">Relation</span><span class="o">.</span><span class="n">CHILD</span>
                <span class="k">if</span> <span class="n">select</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">tok</span><span class="o">.</span><span class="n">KEY_ENTRY</span><span class="p">])</span>
            <span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;node </span><span class="si">{</span><span class="n">parent_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="AppGraph.parent"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.parent">[docs]</a>    <span class="k">def</span> <span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Uid</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the ID for this node&#39;s parent. If this node has no parent</span>
<span class="sd">        it returns None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">u</span>
                <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">in_edges</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">tok</span><span class="o">.</span><span class="n">ATTR_EDGE_KIND</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">ty</span><span class="o">.</span><span class="n">Relation</span><span class="o">.</span><span class="n">ONLY_TREE</span>
            <span class="p">]</span>
            <span class="k">return</span> <span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">parents</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;node </span><span class="si">{</span><span class="n">node_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="AppGraph.commonAncestor"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.commonAncestor">[docs]</a>    <span class="k">def</span> <span class="nf">commonAncestor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">this</span><span class="p">:</span> <span class="n">Uid</span><span class="p">,</span> <span class="n">that</span><span class="p">:</span> <span class="n">Uid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Uid</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the ID of the common ancestor between *this* and *that*. If</span>
<span class="sd">        they have no common ancestor it returns None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="n">this</span> <span class="o">!=</span> <span class="n">that</span> <span class="ow">and</span> <span class="n">this</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">that</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">this</span> <span class="o">&gt;</span> <span class="n">that</span><span class="p">:</span>
                <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">that</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">that</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">this</span> <span class="o">==</span> <span class="n">that</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">this</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="AppGraph.port_edges"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.port_edges">[docs]</a>    <span class="k">def</span> <span class="nf">port_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port_id</span><span class="p">,</span> <span class="n">inp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Uid</span><span class="p">,</span> <span class="n">Uid</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns all edge identifiers connected to/from *port_id*. Can</span>
<span class="sd">        filter the in/out edges by toggling the arguments *inp* and</span>
<span class="sd">        *out*.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">in_edges</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">in_edges</span><span class="p">(</span><span class="n">port_id</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">tok</span><span class="o">.</span><span class="n">ATTR_EDGE_KIND</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">ty</span><span class="o">.</span><span class="n">Relation</span><span class="o">.</span><span class="n">ONLY_GRAPH</span>
            <span class="p">]</span> <span class="k">if</span> <span class="n">inp</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="n">out_edges</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">out_edges</span><span class="p">(</span><span class="n">port_id</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">tok</span><span class="o">.</span><span class="n">ATTR_EDGE_KIND</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">ty</span><span class="o">.</span><span class="n">Relation</span><span class="o">.</span><span class="n">ONLY_GRAPH</span>
            <span class="p">]</span> <span class="k">if</span> <span class="n">out</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="k">return</span> <span class="n">in_edges</span> <span class="o">+</span> <span class="n">out_edges</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;port </span><span class="si">{</span><span class="n">port_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="AppGraph.node_edges"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.node_edges">[docs]</a>    <span class="k">def</span> <span class="nf">node_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">in_outside</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">in_inside</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">out_inside</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out_outside</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Uid</span><span class="p">,</span> <span class="n">Uid</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns all the edge identifiers entering or exiting the *ports* of</span>
<span class="sd">        this node, as list of ID pairs.</span>

<span class="sd">        .. image:: assets/zoti_graph_inout_edges.png</span>
<span class="sd">            :scale: 120%</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">port</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ports</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">port_edges</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">inp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">out_inside</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_ancestor</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">node_id</span><span class="p">))</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">in_outside</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_ancestor</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">node_id</span><span class="p">))</span>
            <span class="p">]</span> <span class="o">+</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">port</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ports</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">port_edges</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">inp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">in_inside</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_ancestor</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">node_id</span><span class="p">))</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">out_outside</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_ancestor</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">node_id</span><span class="p">))</span>
            <span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;node </span><span class="si">{</span><span class="n">node_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="AppGraph.connected_ports"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.connected_ports">[docs]</a>    <span class="k">def</span> <span class="nf">connected_ports</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a path graph representing the journey between two leaf</span>
<span class="sd">        nodes&#39; ports passing through a given *port*, see drawing. The</span>
<span class="sd">        search can be minimized by passing a subgraph to the *graph*</span>
<span class="sd">        argument containing the desired path.</span>

<span class="sd">        .. image:: assets/zoti_graph_connected_ports.png</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">only_graph</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">(),</span> <span class="n">port</span><span class="p">))</span></div>

<div class="viewcode-block" id="AppGraph.end_ports"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.end_ports">[docs]</a>    <span class="k">def</span> <span class="nf">end_ports</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ty</span><span class="o">.</span><span class="n">Uid</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Variant of :meth:`connected_ports` which returns a list with end</span>
<span class="sd">        ports insdead of the entire connected subgraph, i.e., ports</span>
<span class="sd">        whose connectivity degree is 1. In the previous example this</span>
<span class="sd">        would mean ``[&quot;/node1/node2/^o1&quot;, &quot;/node3/node4/^i1&quot;]``</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_ports</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">graph</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">conn</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">conn</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="AppGraph.is_leaf"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.is_leaf">[docs]</a>    <span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uid</span><span class="p">:</span> <span class="n">Uid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Checks if a given node is a leaf(i.e., has no children) &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">uid</span><span class="p">)</span></div>

    <span class="c1"># def has_attr(self, uid, attr, val) -&gt; bool:</span>
    <span class="c1">#     &quot;&quot;&quot;Checks if the entry for *uid* has an attribute *attr* of value *val*.&quot;&quot;&quot;</span>
    <span class="c1">#     return getattr(self.entry(uid), attr, None) == val</span>

<div class="viewcode-block" id="AppGraph.has_ancestor"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.has_ancestor">[docs]</a>    <span class="k">def</span> <span class="nf">has_ancestor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uid</span><span class="p">:</span> <span class="n">Uid</span><span class="p">,</span> <span class="n">ancestor</span><span class="p">:</span> <span class="n">Uid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks if *ancestor* is indeed an ancestor of *uid*.&quot;&quot;&quot;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">uid</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parent</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">parent</span> <span class="o">==</span> <span class="n">ancestor</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_ancestor</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">ancestor</span><span class="p">)</span></div>

<div class="viewcode-block" id="AppGraph.depth"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.depth">[docs]</a>    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks at which depth in the hierarchy tree *uid* is found relative</span>
<span class="sd">        to the global root.&quot;&quot;&quot;</span>
        <span class="n">dph</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">uid</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">parent</span><span class="p">:</span>
            <span class="n">dph</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dph</span></div>

<div class="viewcode-block" id="AppGraph.connect"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.connect">[docs]</a>    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">srcport</span><span class="p">,</span> <span class="n">dstport</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Connects two ports through an edge. If `recursive` is set to</span>
<span class="sd">        ``True`` then it recursively creates intermediate ports and</span>
<span class="sd">        connections if the source and destination nodes belong to</span>
<span class="sd">        different parents. If an *edge* entry is provided then all the</span>
<span class="sd">        new edges will be associated with it, otherwise they will have</span>
<span class="sd">        no entry.</span>

<span class="sd">        .. image:: assets/zoti_graph_connect.png</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_weight</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">tok</span><span class="o">.</span><span class="n">ATTR_EDGE_KIND</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">ty</span><span class="o">.</span><span class="n">Relation</span><span class="o">.</span><span class="n">ONLY_TREE</span>
                    <span class="k">else</span> <span class="mi">9999</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_reg_port</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">templ</span><span class="p">):</span>  <span class="c1"># direction):</span>
            <span class="n">newport</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">withPort</span><span class="p">(</span><span class="n">port</span><span class="o">.</span><span class="n">name</span><span class="p">()),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ports</span><span class="p">(</span><span class="n">node</span><span class="p">),</span>
                <span class="n">modifier</span><span class="o">=</span><span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">withSuffix</span><span class="p">(</span><span class="n">s</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">newentry</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">templ</span><span class="p">)</span>
            <span class="n">newentry</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">newport</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
            <span class="c1"># ty.Port(newport.name(), direction, {}, {}, {}, {}))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">newport</span><span class="p">,</span> <span class="n">newentry</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">register_port</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">newport</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">newport</span>

        <span class="n">attr</span> <span class="o">=</span> <span class="p">{</span><span class="n">tok</span><span class="o">.</span><span class="n">ATTR_EDGE_KIND</span><span class="p">:</span> <span class="n">edge</span><span class="o">.</span><span class="n">kind</span> <span class="k">if</span> <span class="n">edge</span> <span class="k">else</span> <span class="n">ty</span><span class="o">.</span><span class="n">Relation</span><span class="o">.</span><span class="n">EVENT</span><span class="p">,</span>
                <span class="n">tok</span><span class="o">.</span><span class="n">KEY_ENTRY</span><span class="p">:</span> <span class="n">edge</span><span class="p">,</span>
                <span class="p">}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">recursive</span><span class="p">:</span>
                <span class="n">via</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">commonAncestor</span><span class="p">(</span><span class="n">srcport</span><span class="p">,</span> <span class="n">dstport</span><span class="p">)</span>
                <span class="n">srcentry</span><span class="p">,</span> <span class="n">dstentry</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entry</span><span class="p">(</span><span class="n">srcport</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">entry</span><span class="p">(</span><span class="n">dstport</span><span class="p">))</span>
                <span class="n">srcfamily</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">via</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">srcport</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">_weight</span>
                <span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">dstfamily</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">via</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">dstport</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">_weight</span>
                <span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                <span class="c1"># path = ([_reg_port(srcport, n, ty.Dir.OUT) for n in reversed(srcfamily)] +</span>
                <span class="c1">#         [_reg_port(dstport, n, ty.Dir.IN) for n in dstfamily])</span>
                <span class="n">path</span> <span class="o">=</span> <span class="p">([</span><span class="n">_reg_port</span><span class="p">(</span><span class="n">srcport</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">srcentry</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">srcfamily</span><span class="p">)]</span> <span class="o">+</span>
                        <span class="p">[</span><span class="n">_reg_port</span><span class="p">(</span><span class="n">dstport</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">dstentry</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">dstfamily</span><span class="p">])</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="n">srcport</span><span class="p">]</span> <span class="o">+</span> <span class="n">path</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">dstport</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">srcport</span><span class="p">,</span> <span class="n">dstport</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot connect </span><span class="si">{</span><span class="n">srcport</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">dstport</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="AppGraph.bypass_port"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.bypass_port">[docs]</a>    <span class="k">def</span> <span class="nf">bypass_port</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">ensure_fanout</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes the port with a given ID and reconnects its upstream to its</span>
<span class="sd">        downstream connections. Useful when flattening hierarchies,</span>
<span class="sd">        e.g., unclustering the nodes under a ``CompositeNode``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">port</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">delete</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">new_connections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ui</span><span class="p">,</span> <span class="n">vi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">port_edges</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">inp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entry</span><span class="p">(</span><span class="n">ui</span><span class="p">,</span> <span class="n">vi</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">uo</span><span class="p">,</span> <span class="n">vo</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">port_edges</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">inp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ensure_fanout</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">(</span><span class="n">uo</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">(</span><span class="n">vo</span><span class="p">):</span>
                    <span class="n">delete</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">uo</span><span class="p">,</span> <span class="n">vo</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">ui</span><span class="p">,</span> <span class="n">vo</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">new_connections</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ui</span><span class="p">,</span> <span class="n">vo</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">delete</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_connections</span></div>

<div class="viewcode-block" id="AppGraph.copy_tree"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.copy_tree">[docs]</a>    <span class="k">def</span> <span class="nf">copy_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Uid</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copies the entire subgraph under an arbitrary *root* node to</span>
<span class="sd">        sibling a new sibling with *new_name*. Returns the ID of this</span>
<span class="sd">        new sibling.</span>

<span class="sd">        *ATTENTION:* all the copied child nodes will refer to the</span>
<span class="sd">        original entries and will need to be :meth:`decouple` d first</span>
<span class="sd">        if any local alteration is intended.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ATTENTION: children need decoupling</span>
        <span class="k">assert</span> <span class="n">root</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
        <span class="n">new_root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">withNode</span><span class="p">(</span><span class="n">new_name</span><span class="p">)</span>
        <span class="n">all_children</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_ancestor</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">root</span><span class="p">)]</span>
        <span class="n">all_children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">all_children</span><span class="p">)</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">replaceRoot</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">new_root</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()}</span>
        <span class="n">new_G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">relabel_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_G</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">new_root</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_child</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">parent</span><span class="p">(),</span> <span class="n">new_root</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decouple</span><span class="p">(</span><span class="n">new_root</span><span class="p">)</span>
        <span class="n">new_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entry</span><span class="p">(</span><span class="n">new_root</span><span class="p">)</span>
        <span class="n">new_entry</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">new_name</span>
        <span class="k">return</span> <span class="n">new_root</span></div>

<div class="viewcode-block" id="AppGraph.remove_tree"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.remove_tree">[docs]</a>    <span class="k">def</span> <span class="nf">remove_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">with_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes the entire subgraph under an arbitrary *root*</span>
<span class="sd">        node. *with_root* toggles whether or not the root node will</span>
<span class="sd">        also be deleted.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">root</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
        <span class="n">all_children</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_ancestor</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">root</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">with_root</span><span class="p">:</span>
            <span class="n">all_children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">all_children</span><span class="p">)</span></div>

<div class="viewcode-block" id="AppGraph.cluster"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.cluster">[docs]</a>    <span class="k">def</span> <span class="nf">cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">children</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clusters the *children* nodes represented with a list of IDs under</span>
<span class="sd">        a (fully-created and instantiated) *node*. Both *node* and</span>
<span class="sd">        *children* need to belong the same parent, otherwise an error</span>
<span class="sd">        is thrown.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Cannot cluster </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">children</span><span class="p">)</span><span class="si">}</span><span class="s2"> under </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot; They do not have the same parent.&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">clust</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">clust</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">register_child</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
            <span class="n">outside</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_edges</span><span class="p">(</span>
                    <span class="n">child</span><span class="p">,</span> <span class="n">in_outside</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">out_outside</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">clust</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">u</span><span class="p">))</span> <span class="ow">and</span>
                        <span class="n">clust</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">outside</span><span class="p">:</span>
                <span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entry</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="n">edge</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span></div>

<div class="viewcode-block" id="AppGraph.uncluster"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.uncluster">[docs]</a>    <span class="k">def</span> <span class="nf">uncluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unclusters all children of a node and reconnects them in the</span>
<span class="sd">        context of *parent*. If *parent* is not provided, then it is</span>
<span class="sd">        assumed to be the parent of *node*. Finally, *node* is removed</span>
<span class="sd">        along with all its ports.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span> <span class="k">if</span> <span class="n">parent</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c1"># TODO: exception maybe?</span>
        <span class="k">for</span> <span class="n">port</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ports</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bypass_port</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">register_child</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span></div>

<div class="viewcode-block" id="AppGraph.fuse_nodes"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.fuse_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">fuse_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">along_edges</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fuses two nodes *n1* and *n2* into a single node containing all</span>
<span class="sd">        children and all ports belonging to both actors. The fused</span>
<span class="sd">        node will bear the name and ID of *n1*. The argument</span>
<span class="sd">        *along_edges* can be used to skip searching which edges</span>
<span class="sd">        connect *n1* and *n2*.</span>

<span class="sd">        *ATTENTION:* rather unstable! It is the caller&#39;s job to check that the</span>
<span class="sd">        resulting graph is consistent.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">along_edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">along_edges</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">only_graph</span><span class="p">(</span><span class="n">with_ports</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">edges</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">]</span>
            <span class="p">]</span>
        <span class="c1"># print(&quot;FUSING NODES&quot;, n1, n2)</span>
        <span class="k">for</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span> <span class="ow">in</span> <span class="n">along_edges</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bypass_port</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">ensure_fanout</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bypass_port</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">port</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ports</span><span class="p">(</span><span class="n">n2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">register_port</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
            <span class="c1"># print(&quot;REGISTERED PORT&quot;, port, &quot;TO&quot;, n1)</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">n2</span><span class="p">):</span>
            <span class="n">ch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_child</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
            <span class="c1"># print(&quot;REGISTERED NODE&quot;, ch, &quot;TO&quot;, n1)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span></div>
        <span class="c1"># print(&quot;REMOVED&quot;, n2)</span>

<div class="viewcode-block" id="AppGraph.node_projection"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.node_projection">[docs]</a>    <span class="k">def</span> <span class="nf">node_projection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">with_parent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Displays the projection of nodes upon a single level of hierarchy</span>
<span class="sd">        for all first children of *parent*. *with_parent* toggles</span>
<span class="sd">        whether the connections to/from the parent node are included</span>
<span class="sd">        in the projection or not.</span>

<span class="sd">        In the returned view each edge between two nodes will contain</span>
<span class="sd">        only a ``ports`` entry holding a list of tuples reflecting the</span>
<span class="sd">        original port connections between the source and target node.</span>

<span class="sd">        .. image:: assets/zoti_graph_projection.png</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_filter</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">):</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="n">n2</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">tok</span><span class="o">.</span><span class="n">ATTR_EDGE_KIND</span><span class="p">,</span> <span class="n">ty</span><span class="o">.</span><span class="n">Relation</span><span class="o">.</span><span class="n">NONE</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">kind</span> <span class="o">&amp;</span> <span class="n">ty</span><span class="o">.</span><span class="n">Relation</span><span class="o">.</span><span class="n">ONLY_GRAPH</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ports</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span> <span class="k">if</span> <span class="n">with_parent</span> <span class="k">else</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1">#     [p for p in self.ports(parent) if all([</span>
        <span class="c1">#         self.has_ancestor(u, parent) and self.has_ancestor(v, parent)</span>
        <span class="c1">#         for u, v in self.port_edges(p, inp=True, out=True)</span>
        <span class="c1">#     ])]</span>
        <span class="c1"># )</span>
        <span class="n">nodes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">(</span>
            <span class="n">parent</span><span class="p">,</span>
            <span class="n">select</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">with_parent</span> <span class="k">else</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">n</span><span class="p">,</span> <span class="n">ty</span><span class="o">.</span><span class="n">Primitive</span><span class="p">)</span>
        <span class="p">))</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">parent</span><span class="p">):</span>
            <span class="n">nodes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ports</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
        <span class="n">cluster</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">subgraph_view</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="p">,</span> <span class="n">filter_node</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">filter_edge</span><span class="o">=</span><span class="n">_filter</span>
        <span class="p">)</span>
        <span class="n">view</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
        <span class="c1"># print(cluster.edges)</span>
        <span class="c1"># print(cluster.nodes)</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cluster</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="n">src</span> <span class="o">=</span> <span class="n">u</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="n">parent</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">entry</span><span class="p">(</span>
                <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">dir</span> <span class="o">==</span> <span class="n">ty</span><span class="o">.</span><span class="n">Dir</span><span class="o">.</span><span class="n">INOUT</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="n">dst</span> <span class="o">=</span> <span class="n">v</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="n">parent</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">entry</span><span class="p">(</span>
                <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">dir</span> <span class="o">==</span> <span class="n">ty</span><span class="o">.</span><span class="n">Dir</span><span class="o">.</span><span class="n">INOUT</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">src</span> <span class="o">==</span> <span class="n">dst</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">view</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">):</span>
                <span class="n">view</span><span class="p">[</span><span class="n">src</span><span class="p">][</span><span class="n">dst</span><span class="p">][</span><span class="s2">&quot;ports&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">view</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">ports</span><span class="o">=</span><span class="p">[(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)])</span>

        <span class="k">return</span> <span class="n">view</span></div>

<div class="viewcode-block" id="AppGraph.only_tree"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.only_tree">[docs]</a>    <span class="k">def</span> <span class="nf">only_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">with_ports</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a graph view representing only the hierarchy between</span>
<span class="sd">        nodes. If *root* is provided, only the sub-tree under it is</span>
<span class="sd">        captured by the view. *with_ports* toggles whether ports are</span>
<span class="sd">        included in this view or not.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_nodes</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">is_in_subgraph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_ancestor</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span> <span class="k">if</span> <span class="n">root</span> <span class="k">else</span> <span class="kc">True</span>
            <span class="n">include_port</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">with_ports</span> <span class="k">else</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ty</span><span class="o">.</span><span class="n">Port</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">is_in_subgraph</span> <span class="ow">and</span> <span class="n">include_port</span>

        <span class="k">def</span> <span class="nf">_edges</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">):</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="n">n2</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">tok</span><span class="o">.</span><span class="n">ATTR_EDGE_KIND</span><span class="p">,</span> <span class="n">ty</span><span class="o">.</span><span class="n">Relation</span><span class="o">.</span><span class="n">NONE</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">kind</span> <span class="o">&amp;</span> <span class="n">ty</span><span class="o">.</span><span class="n">Relation</span><span class="o">.</span><span class="n">ONLY_TREE</span>

        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">subgraph_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="p">,</span> <span class="n">filter_node</span><span class="o">=</span><span class="n">_nodes</span><span class="p">,</span> <span class="n">filter_edge</span><span class="o">=</span><span class="n">_edges</span><span class="p">)</span></div>

<div class="viewcode-block" id="AppGraph.only_graph"><a class="viewcode-back" href="../../api-reference.html#zoti_graph.appgraph.AppGraph.only_graph">[docs]</a>    <span class="k">def</span> <span class="nf">only_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">with_ports</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a graph view representing only the application graph. If</span>
<span class="sd">        *root* is provided only the sub-graph under it is included in the</span>
<span class="sd">        view. *with_ports* toggles whether ports are included in this view or</span>
<span class="sd">        not.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_nodes</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">is_in_subgraph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_ancestor</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span> <span class="k">if</span> <span class="n">root</span> <span class="k">else</span> <span class="kc">True</span>
            <span class="n">include_port</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">with_ports</span> <span class="k">else</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ty</span><span class="o">.</span><span class="n">Port</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">is_in_subgraph</span> <span class="ow">and</span> <span class="n">include_port</span>

        <span class="k">def</span> <span class="nf">_edges</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">):</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="n">n2</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">tok</span><span class="o">.</span><span class="n">ATTR_EDGE_KIND</span><span class="p">,</span> <span class="n">ty</span><span class="o">.</span><span class="n">Relation</span><span class="o">.</span><span class="n">NONE</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">kind</span> <span class="o">&amp;</span> <span class="n">ty</span><span class="o">.</span><span class="n">Relation</span><span class="o">.</span><span class="n">ONLY_GRAPH</span>

        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">subgraph_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ir</span><span class="p">,</span> <span class="n">filter_node</span><span class="o">=</span><span class="n">_nodes</span><span class="p">,</span> <span class="n">filter_edge</span><span class="o">=</span><span class="n">_edges</span><span class="p">)</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">zoti-graph</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../the-zoti-graph-model.html">Model Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-reference.html">API Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Links</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/Ericsson/zoti/tree/main/zoti-yaml">GitHub</a></li>
<li class="toctree-l1"><a class="reference external" href="https://ericsson.github.io/zoti/">ZOTI</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Ericsson S&T.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>